---
id: slidingWindow
title: '滑动窗口'
tags: [滑动窗口]
keywords: [无重复字符的最长子串]
description: 无重复字符的最长子串
last_update:
  date: 6/27/2024
  author: ZhangJiaxiang
---

## [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

### 返回长度

```js
function lengthOfLongestSubstring(string) {
  let left = 0 // 当前无重复子串的起始索引(滑动窗口左边)
  let maxLength = 0 // 最长无重复子串的长度
  const charSet = new Set()

  for (let right = 0; right < string.length; right++) {
    const rightChar = string.charAt(right)
    while (charSet.has(rightChar)) {
      charSet.delete(string.charAt(left))
      left++
    }
    charSet.add(rightChar)
    maxLength = Math.max(maxLength, right - left + 1)
  }
  return maxLength
}
```

1. 使用一个 Set 来记录当前窗口中的字符。
2. 使用两个指针 left 和 right 代表当前窗口的左右边界。
3. 当遇到重复字符时，移动 left 指针并从集合中移除字符，直到窗口中没有重复字符。
4. 每次更新窗口大小 right - left + 1(索引从 0 开始,如:left:0,right:2,实际表示有三个.所以要加 1)，并更新结果 res。

这道题要求返回最大长度.滑动窗口(set)并不代表当前最大的长度,所以每次要对比当前窗口的长度与最大长度,取最大值.

### 返回子串

```js
function lengthOfLongestSubstring(string) {
  const lastSeen = new Map() // 记录每个字符的最后出现位置。
  let left = 0 // 当前无重复子串的起始索引(滑动窗口左边)
  let maxLength = 0 // 最长无重复子串的长度
  let longestStartIdx = 0 // 最长无重复子串的起始索引

  for (let right = 0; right < string.length; right++) {
    const char = string.charAt(right)

    if (lastSeen.has(char) && lastSeen.get(char) >= left) {
      left = lastSeen.get(char) + 1
    }

    lastSeen.set(char, right)

    if (right - left + 1 > maxLength) {
      maxLength = right - left + 1
      longestStartIdx = left
    }
  }

  return string.slice(longestStartIdx, longestStartIdx + maxLength)
}
```

和上一个返回长度的思路类似,这次是返回整个子串.所以要增加变量,`longestStartIdx`记录字串起始位置,`lastSeen`记录每个字符的最后出现位置.

滑动窗口:
• 如果遇到重复字符，更新 left,将窗口右移到重复字符的下一个位置。
• 更新当前字符的最后出现位置。
• 检查并更新最长无重复子串的长度和起始索引。
