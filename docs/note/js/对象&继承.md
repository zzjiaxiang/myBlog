---
id: createProject
title: 创建对象方式,继承
tags: [创建对象方式, 继承]
keywords: [创建对象方式, 继承]
description: 创建对象方式,继承
last_update:
  date: 6/16/2024
  author: ZhangJiaxiang
---

## 创建对象的多种方式以及优缺点

### 1.工厂模式

```ts
function createPerson(name) {
  var o = new Object()
  o.name = name
  o.getName = function () {
    console.log(this.name)
  }

  return o
}

const person1 = createPerson('kevin')
```

缺点：对象无法识别，因为所有的实例都指向一个原型

### 2.构造函数模式

```ts
function Person(name) {
  this.name = name
  this.getName = function () {
    console.log(this.name)
  }
}

const person1 = new Person('kevin')
```

优点：实例可以识别为一个特定的类型

缺点：每次创建实例时，每个方法都要被创建一次

## 继承

### 原型链继承

```ts
function Parent() {
  this.name = 'kevin'
}

function Child() {}

Child.prototype = new Parent()

const child1 = new Child()

console.log(child1.name) // kevin
```

缺点:

1. 引用类型的属性被所有实例共享
2. 在创建 Child 的实例时，不能向 Parent 传参

### 借用构造函数(经典继承)

使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）

```ts
function Parent() {
  this.names = ['kevin', 'daisy']
}

function Child() {
  // 继承自Parent
  Parent.call(this)
}

const child1 = new Child()

child1.names.push('yayu')

console.log(child1.names) // ["kevin", "daisy", "yayu"]

const child2 = new Child()

console.log(child2.names) // ["kevin", "daisy"]
```

核心代码是 Parent.call(this)，创建子类实例时调用 Parent 构造函数，于是 Child 的每个实例都会将 Child 中的属性复制一份。

缺点：

- 只能继承父类的实例属性和方法，不能继承原型属性/方法
- 无法实现复用，每个子类都有父类实例函数的副本，影响性能

### 组合继承

组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。

```ts
function Parent(name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}

function Child(name, age) {
  // 第二次调用
  Parent.call(this, name)

  this.age = age
}

Child.prototype = new Parent() // 第一次调用
Child.prototype.constructor = Child

const child1 = new Child('kevin', '18')
```

缺点：

- 第一次调用 Parent()：给 Child.prototype 写入两个属性 name，colors。
- 第二次调用 Parent()：给 child1 写入两个属性 name，colors。
  组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。

### 原型式继承

```ts
function object(obj) {
  function F() {}
  F.prototype = obj
  return new F()
}
```

就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。

缺点：

包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

### 寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

```ts
function createObj(o) {
  const clone = Object.create(o)
  clone.sayName = function () {
    console.log('hi')
  }
  return clone
}
```

缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

### 寄生组合式继承

```ts
function inheritPrototype(Child, Parent) {
  const prototype = Object.create(Parent.prototype) // 创建对象，创建父类原型的一个副本
  prototype.constructor = Child // 增强对象，弥补因重写原型而失去的默认的constructor 属性
  Child.prototype = prototype // 指定对象，将新创建的对象赋值给子类的原型
}
```

## 参考

[https://github.com/mqyqingfeng/Blog/issues/15](https://github.com/mqyqingfeng/Blog/issues/15)

[https://github.com/mqyqingfeng/Blog/issues/16](https://github.com/mqyqingfeng/Blog/issues/16)

[https://github.com/yygmind/blog/issues/7](https://github.com/yygmind/blog/issues/7)
